module buildmessages; 

import het, het.parser; 

class DMDMessage
{
	mixin((
		(表([
			[q{/+Note: Type : ubyte+/},q{/+Note: Prefixes+/},q{/+Note: ShortCaption+/},q{/+Note: ColorCode+/},q{/+Note: Color+/},q{/+Note: Syntax+/}],
			[q{unknown},q{""},q{""},q{""},q{clBlack},q{skWhitespace}],
			[],
			[q{find},q{"Find: "},q{"Find"},q{""},q{clSilver},q{skFoundAct}],
			[],
			[q{error},q{"Error: "},q{"Err"},q{"\33\14"},q{clRed},q{skError}],
			[q{warning},q{"Warning: "},q{"Warn"},q{"\33\16"},q{clYellow},q{skWarning}],
			[q{deprecation},q{"Deprecation: "},q{"Depr"},q{"\33\13"},q{clAqua},q{skDeprecation}],
			[q{console},q{"Console: "},q{"Con"},q{""},q{clWhite},q{skConsole}],
			[],
			[q{todo},q{"Todo: "},q{"Todo"},q{"\33\11"},q{clBlue},q{skTodo}],
			[q{opt},q{"Opt: "},q{"Opt"},q{"\33\15"},q{clFuchsia},q{skOpt}],
			[q{bug},q{"Bug: "},q{"Bug"},q{"\33\6"},q{clOrange},q{skBug}],
			[],
			[q{//Order is important: it defines paint order
			}],
		]))
	) .GEN!q{GEN_enumTable}); 
	private enum exceptionPrefix = "Exception: "; //handled specuially
	
	CodeLocation location; 
	Type type; 
	string content, lineSource;  //Todo: lineSource is not needed, also sometimes it's bogus in LDC
	
	int count = 1; //occurences of this message in the multi-module build
	
	DMDMessage[] subMessages; //it's a tree
	
	protected uint hash_; @property hash() => hash_; 
	
	bool isException; //It's a special error message. It looks red/yellow in DIDE.
	
	this(
		CodeLocation location_, 
		string content_, 
		Type type_=Type.unknown
	) {
		location = location_; 
		content = content_; 
		type = type_; 
		detectType; 
		recalculateHash; 
	} 
	
	this(CodeLocation location_, Type type_, string content_)
	{ this(location_, content_, type_); } 
	
	this(DMDMessage m)
	{
		location = m.location; 
		content = m.content; 
		type = m.type; 
		lineSource = m.lineSource; 
		count = m.count; 
		hash_ = m.hash; 
		subMessages = (mixin(求map(q{s},q{m.subMessages},q{s.dup}))).array; 
	} 
	
	auto dup()
	{ return new DMDMessage(this); } 
	
	void recalculateHash()
	{
		ulong h = location.hashOf	(type.hashOf(content.hashOf)); 
		
		//make every console message different
		if(type==Type.console) h += (cast(ulong)((cast(void*)(this)))); 
		
		hash_ = (cast(uint)(h)) + (cast(uint)(h>>32)); 
	} 
	
	@property col() const
	{ return location.columnIdx; } @property line() const
	{ return location.lineIdx; } @property mixinLine() const
	{ return location.mixinLineIdx; } 
	
	@property typePrefix() const {
		return ((
			type==Type.error 
			&& isException
		)?("Exception: ") :(typePrefixes[type])); 
	} 
	
	bool opEquals(in DMDMessage b)const
	{
		return 	location 	== b.location 	&&
			type	== b.type 	&&
			content	== b.content; 
	}  int opCmp(const DMDMessage b) const
	{
		return 	cmp(location, b.location)
			.cmpChain(cmp(type, b.type))
			.cmpChain(cmp(content, b.content)); 
	} 
	bool isSupplemental() const
	{ return type==Type.unknown && content.startsWith(' '); } 
	
	bool isInstantiatedFrom() const
	{
		return 	isSupplemental && 	(
			content.stripLeft.startsWith("instantiated from here: ") 	||
			content.endsWith(" instantiations, -v to show) ...") 	||
			content.canFind(" recursive instantiations from here: ")
		); 
	} 
	
	///A persistend message is written in the code, it's not generated by a compiler.
	bool isPersistent() const
	{ with(Type) return !!type.among(todo, bug, opt); } 
	
	protected void detectType()
	{
		if(type!=Type.unknown) return; 
		
		bool doit(string prefix)
		{
			if(content.startsWith(prefix))
			{
				content = content[prefix.length .. $]; 
				return true; 
			}
			return false; 
		} 
		
		
		foreach(i, prefix; typePrefixes)
		if(i && doit(prefix))
		{ type = (cast(Type)(i));  return; }
		
		if(doit(exceptionPrefix))
		{
			/+Note: It's counted as an error, but looks different in DIDE+/
			type = Type.error; isException = true; return; 
		}
	} 
	string toString_internal(int level, bool enableColor, string indentStr) const
	{
		auto res = 	indentStr.replicate(level) ~
			withEndingColon(location.text) ~
			((enableColor)?(typeColorCode[type]):("")) ~ typePrefix ~
			((enableColor)?("\33\7"):("")) ~ content; 
		
		foreach(const ref sm; subMessages)
		res ~= "\n" ~ sm.toString_internal(level + sm.isInstantiatedFrom, enableColor, indentStr); 
		
		return res; 
	} 
	
	override string toString() const
	{ return toString_internal(0, true, "  "); } 
	
	private static
	{
		static withEndingColon(string s)
		{ return ((s=="")?(""):(s~": ")); }  static withStartingSpace(string s)
		{ return ((s=="")?(""):(" "~s)); } 
		
		int[] findQuotePairIndices(string s)
		{
			int[] indices; 
			foreach(i, char ch; s) if(ch=='`') indices ~= i.to!int; 
			
			if(indices.length & 1)
			{
				indices = indices.remove(max(indices.length.to!int - 2, 0)); 
				//it removes the second rightmost element. The leftmost and the rightmost are always valid.
			}
			return indices; 
		} 
		
		static string encapsulateCodeBlocks(string msg)
		{
			//locate all the code snippets inside `` and surround them with / +Code: ... + /
			const indices = findQuotePairIndices(msg); 
			auto opening = false; 
			foreach_reverse(i; indices)
			{
				const 	left = msg[0 .. i],
					right = msg[i+1 .. $]; 
				
				auto separ = opening ? "/+Code: " :"+/"; 
				if(left.endsWith(separ[1])) separ = ' ' ~ separ; //Not to produce "/+/" or "+/+"
				
				msg = left ~ separ ~ right; 
				opening = !opening; 
			}
			
			return msg; 
		} 
	} 
	
	
	private string[] allRecursiveContentLines() const
	{ return content ~ subMessages.map!((sm)=>(sm.allRecursiveContentLines)).join; } 
	
	private string sourceText_internal(int level=0) const
	{
		if(isPersistent/+Note: Todo/Bug/Opt messages are handled in a special fashion+/)
		{
			auto lines = allRecursiveContentLines; 
			
			lines[0] = typePrefix ~ lines[0]; 
			if(lines.length>1)
			{
				//Outdent all lines but the first.
				auto prefix = lines[1..$].map!(s=>s[0..$-s.stripLeft.length]).fold!commonPrefix; 
				foreach(ref s; lines[1..$]) s = s.withoutStarting(prefix); 
			}
			
			auto res = safeDCommentBody(lines.join('\n')) ~ " /+$DIDE_LOC "~location.text~"+/"; 
			
			return res; 
		}
		
		auto res = 	"\t".replicate(level) ~
			typePrefix ~
			encapsulateCodeBlocks(safeDCommentBody(content.stripLeft)) ~
			((location)?(" /+$DIDE_LOC "~location.text~"+/"):("")); 
		
		foreach(const ref sm; subMessages)
		res ~= "\n"~sm.sourceText_internal(level + sm.isInstantiatedFrom); 
		
		return res; 
	} 
	
	string sourceText() const
	{ return "/+\n" ~ sourceText_internal ~ "\n+/"; } 
	
	CodeLocation[] allLocations() const
	{
		CodeLocation[] res; 
		if(location) res ~= location; 
		foreach(const m; subMessages)
		res ~= m.allLocations; 
		return res; 
	} 
	
	string oneLineText() const
	{ return typePrefix~content.firstLine; } 
} 


struct DMDMessageDecoder
{
	DMDMessage[] messages;  //globally accumulated messages for all modules
	
	//accumulators only for the last batch of std lines
	DMDMessage[] updatedMessages; 
	string[] pragmas; 
	
	
	//message filtering
	
	__gshared string[] messageFilters = [
		//"Warning: C preprocessor directive ", 
		"Deprecation: token string requires valid D tokens, not"
	]; 
	/+
		Todo: Put these filters in the main DIDE/settings!
		Counters would be usefull for every hits in the recent build.
	+/
	
	//internal state
	private
	{
		DMDMessage[uint] messageMap; 
		FileNameFixer fileNameFixer; 
		
		//Manage states for many sourcefiles.  While the message array is common.
		File _actSourceFile; 
		DMDMessage parentMessage, topLevelParentMessage; 
		
		DMDMessage[2][File] _actSourceFileState; 
	} 
	
	@property actSourceFile()
	{ return _actSourceFile; } 
	
	@property void actSourceFile(File f)
	{
		if(f==actSourceFile) return; 
		_actSourceFileState[_actSourceFile] = [parentMessage, topLevelParentMessage]; 
		
		_actSourceFile = f; //print("selecting source file: ", f); 
		
		if(auto a = _actSourceFile in _actSourceFileState)
		{ parentMessage = (*a)[0], topLevelParentMessage = (*a)[1]; }
		else
		{ parentMessage = null, topLevelParentMessage = null; }
	} 
	
	
	void createFileNameFixerIfNeeded()
	{ if(!fileNameFixer) fileNameFixer = new FileNameFixer; } 
	
	@property void defaultPath(Path path)
	{
		createFileNameFixerIfNeeded; 
		fileNameFixer.defaultPath = path; 
	} 
	
	string sourceText() const
	{ return messages.map!"a.sourceText".join("\n"); } 
	
	private static bool keepMessage(in DMDMessage m)
	{
		foreach(f; messageFilters)
		if(joiner(only(m.typePrefix, m.content)).startsWith(f))
		return false; 
		
		return true; 
	} 
	
	void addConsoleMessage(string[] lines)
	{
		if(lines.empty) return; 
		const s = lines.join('\n'); 
		if(s.strip=="") return; 
		messages ~= new DMDMessage(
			CodeLocation(actSourceFile.fullName), 
			DMDMessage.Type.console, 
			s
		); 
		updatedMessages ~= messages.back; 
	} 
	
	
	static auto rxDMDMessage()
	=> 
	rtRegex!	`^((\w:\\)?[\w\\ \-.,]+.d)(-mixin-([0-9]+))?[^(]*\(([0-9]+),([0-9]+)\): (.*)`
		/+1:fn 2:drive       3       4            5      6       7+/
		/+drive:\ is optional.+/
		/+Todo: detect multiple mixin line indices!+/; 
	
	static int decodeColumnMarker(string s)
	{
		return ((
			s.endsWith('^') &&
			(
				s.length==1 || 
				s[0..$-1].all!"a.among(' ', '\t')"
			)
		)?((cast(int)(s.length))):(0)); 
	} 
	static bool isColumnMarker(string s)
	{ return decodeColumnMarker(s)>0; }; 
	
	
	static bool isDMDMessage(string s)
	{
		auto m = matchFirst(s, rxDMDMessage); 
		return !m.empty; 
	} 
	
	static bool isDMDMainMessage(string s)
	{
		auto m = matchFirst(s, rxDMDMessage); 
		if(!m.empty)
		{
			DMDMessage msg; 
			with(msg)
			{
				content = m[7]; detectType; 
				return type!=Type.unknown; 
			}
		}
		return false; 
	} 
	
	void processDMDOutput_partial(ref string[] lines, bool isFinal)
	{
		if(lines.empty) return; 
		
		if(isFinal)
		{
			processDMDOutput(lines); 
			lines = []; 
		}
		else
		{
			auto prevLines = lines; 
			
			while(lines.length)
			{
				const s = lines.back; 
				
				//from here, break if it's a valid ending
				if(isColumnMarker(s)) { break; }
				else if(isDMDMessage(s))
				{
					const dqCnt = s.count('`'); 
					if(
						!dqCnt
						/+has no quotation inside+/
					) break; 
					if(
						(dqCnt%2==0) && 
						(s.count('"')==0) && 
						(s.count('\'')==0)
						/+
							has even quotation, 
							but no other strings
						+/
					) break; 
				}
				lines.popBack; 
			}
			
			processDMDOutput(lines); 
			lines = prevLines[lines.length..$]; 
		}
		
		/+
			Todo: These message ending detections are error prone with 
			DIDE_EXTERNAL_COMPILATION_REQUEST 
			messages.  Those haveproper  message endings. 
			And also out of memory exceptions should be processed.
		+/
	} 
	
	DMDMessage[] fetchUpdatedMessages()
	{
		//add remaining pragmas first to messages
		addConsoleMessage(pragmas.fetchAll); 
		
		//then fetch all new or modified messages
		return updatedMessages.fetchAll; 
	} 
	
	void processDMDOutput(string[] lines)
	{
		if(lines.empty) return; 
		
		createFileNameFixerIfNeeded; 
		
		static File decodeFileMarker(string line, FileNameFixer fileNameFixer)
		{
			auto rx = rtRegex!`^(\w:\\[\w\\ \-.,]+.d): COMPILER OUTPUT:$`; 
			auto m = matchFirst(line, rx); 
			return m.empty ? File.init : fileNameFixer(m[1]); 
			/+
				Todo: This file marker is kinda deprecated. 
				No need to collect all the messages from all modules into a single text.
			+/
		} 
		
		static DMDMessage fetchDMDMessage(ref string[] lines, FileNameFixer fileNameFixer)
		{
			DMDMessage decodeDMDMessage(string s)
			{
				auto m = matchFirst(s, rxDMDMessage); 
				if(!m.empty)
				{
					return new DMDMessage
						(
						CodeLocation(
							fileNameFixer(m[1]).fullName, 
							m[5].to!int.ifThrown(0), 
							m[6].to!int.ifThrown(0), 
							m[4].to!int.ifThrown(0)
						), 
						m[7]
					); 
				}
				
				return null; 
			} 
			
			static bool checkColumnIndices(int markerCol, string prevLine, int msgCol)
			{
				/+
					In rare cases, /+Code: markerCol+/ is lower, because it counts multibyte UTF-8 chars as 1,
					while /+Code: msgCol+/ counts all UTF-8 bytes.
				+/
				
				if(msgCol<=0 || markerCol<=0) return false; 
				
				//return markerCol>0 && msgCol>0; 
				
				version(all)
				{
					size_t markerBytes, len = prevLine.length; 
					foreach(k; 0..markerCol-1)
					{
						if(markerBytes<len) prevLine.decode!(Yes.useReplacementDchar)(markerBytes); 
						else return false; 
					}
					
					/+
						print("--------------- marker column suck 2-------------"); 
						print("markerBytes:", markerBytes); 
						print("markerCol:", markerCol, "  prevLine: ", prevLine.quoted, "  msgCol:", msgCol); 
					+/
					
					enum LDC141 = true; 
					static if(LDC141)
					return /+Fix because some new deprecation warnings has bad indices.+/
					markerBytes>=msgCol-1; 
					else
					return markerBytes==msgCol-1; 
				}
			} 
			auto msg = decodeDMDMessage(lines.front); 
			if(msg)
			{
				int endIdx; 
				foreach(i; 1 .. lines.length.to!int)
				{
					if(
						i>=2 &&
						checkColumnIndices(decodeColumnMarker(lines[i]), lines[i-1], msg.col)
					)
					{ endIdx = i; break; }
					if(decodeDMDMessage(lines[i])) break; 
					if(decodeFileMarker(lines[i], fileNameFixer)) break; 
				}
				
				if(endIdx>=2 /+Note: endIdx==1 is invalid, that's  the cited line.+/)
				{
					lines.fetchFront; //first line of a multiline message
					foreach(i; 1..endIdx-1)
					if(lines.length)
					msg.content ~= "\n"~lines.fetchFront; 
					msg.lineSource = lines.fetchFront; 
					lines.fetchFront; //skip the marker line
				}
				else
				{
					lines.fetchFront; //slingle line message
				}
			}
			return msg; 
		} 
		
		while(lines.length)
		{
			if(auto msg = fetchDMDMessage(lines, fileNameFixer))
			{
				auto chg = false; 
				if(msg.isSupplemental && parentMessage)
				{
					auto idx = parentMessage.subMessages.map!"a.hash".countUntil(msg.hash); 
					if(idx>=0)
					{
						parentMessage = parentMessage.subMessages[idx]; 
						parentMessage.count++; 
					}
					else
					{
						parentMessage.subMessages ~= msg; chg = true; /+new subMessage added+/
						parentMessage = msg; 
					}
				}
				else
				{
					if(msg.isSupplemental)
					WARN("No parent message for supplemental message:", msg); 
					
					if(keepMessage(msg))
					{
						const hash = msg.hash; 
						if(auto m = hash in messageMap)
						{
							(*m).count++; /+already exists+/
							parentMessage = *m; 
						}
						else
						{
							messages ~= msg; chg = true; /+new top level message added+/
							messageMap[hash] = msg; 
							parentMessage = msg; 
						}
						topLevelParentMessage = parentMessage; 
					}
				}
				if(chg && topLevelParentMessage && !updatedMessages.endsWith(topLevelParentMessage))
				{ updatedMessages ~= topLevelParentMessage; }
			}
			else
			{ pragmas ~= lines.fetchFront; }
		}
		
	} 
} 

DMDMessage[] decodeDMDMessages(string err, File file = File.init)
{
	DMDMessageDecoder dec; 
	dec.actSourceFile = file; 
	dec.processDMDOutput(err.splitLines); 
	return dec.fetchUpdatedMessages; 
} 

mixin((
	(表([
		[q{/+Note: ModuleBuildState+/},q{/+Note: Colors+/}],
		[q{notInProject},q{clBlack}],
		[q{queued},q{clWhite}],
		[q{compiling},q{clWhite}],
		[q{aborted},q{clGray}],
		[q{hasErrors},q{clRed}],
		[q{hasWarnings},q{(RGB(128, 255, 0))}],
		[q{hasDeprecations},q{(RGB(64, 255, 0))}],
		[q{flawless},q{clLime}],
	]))
) .GEN!q{GEN_enumTable}); 

bool buildStateIsCompleted(ModuleBuildState a)
{ with(ModuleBuildState) return !!a.among(hasWarnings, hasDeprecations, flawless); } 